---
title: "NYC Taxi Data"
author: "Andreas Hadimulyono"
output: html_document
---

``` {r, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
library(ggplot2)
library(ggmap)
library(dplyr)
library(reshape2)
library(zoo)
library(scales)
library(extrafont)
library(grid)
library(rgdal)
library(maptools)
gpclibPermit()
source("helpers.R")

# helper for t-test
# m1, m2: the sample means
# s1, s2: the sample standard deviations
# n1, n2: the same sizes
# m0: the null value for the difference in means to be tested for. Default is 0. 
# equal.variance: whether or not to assume equal variance. Default is FALSE. 
t.test2 <- function(m1,m2,s1,s2,n1,n2,m0=0,equal.variance=FALSE)
{
    if( equal.variance==FALSE ) 
    {
        se <- sqrt( (s1^2/n1) + (s2^2/n2) )
        # welch-satterthwaite df
        df <- ( (s1^2/n1 + s2^2/n2)^2 )/( (s1^2/n1)^2/(n1-1) + (s2^2/n2)^2/(n2-1) )
    } else
    {
        # pooled standard deviation, scaled by the sample sizes
        se <- sqrt( (1/n1 + 1/n2) * ((n1-1)*s1^2 + (n2-1)*s2^2)/(n1+n2-2) ) 
        df <- n1+n2-2
    }      
    t <- (m1-m2-m0)/se 
    dat <- c(m1-m2, se, t, 2*pt(-abs(t),df))    
    names(dat) <- c("Difference of means", "Std Error", "t", "p-value")
    return(dat) 
}
```


### 1. GOING TO AIRPORT

**Question**

Assuming your office is midtown, and you will like to fly to las vegas for the weekend.

Using the following assumptions:

* that both airports will have the same checkin and security queues, (you need to arrive an hour before departure)

* and both will have equal flight times to Las Vegas

Evaluate the following:

* which airport will allow you to minimize total travel time (the time you leave your office to the time you land in las vegas)

* what is the optimum time for departure assuming that you can leave New York after 9am on Friday.

**Answer**

There are three airports in New York: La Guardia, JFK, and Newark. In order to answer the question, we must first prepare the dataset for the analysis.

The dataset will be the all trips originating from Midtown boroughs, and ending in one of the airports, which will be indicated by the gid

* La Guardia (LGA): 1840
* JFK (JFK): 2056
* Newark (EWR): 2167

As the question is interested in weekend getaways, the datasets shall be filtered only for Fridays, and then eventually grouped by the pickup hour.

The caveat for this analysis is as the Uber trips do not have the destination latitude/longitude, they will not be part of the dataset.

```
-- Step 1. Find all the trips ending in LGA, JFK, or EWR

CREATE TABLE airport_trips AS
SELECT
  id,
  cab_type_id,
  pickup_datetime,
  dropoff_datetime,
  pickup_longitude,
  pickup_latitude,
  dropoff_longitude,
  dropoff_latitude,
  total_amount,
  payment_type,
  pickup_nyct2010_gid,
  dropoff_nyct2010_gid,
  CASE
    WHEN dropoff_nyct2010_gid = 1840 THEN 'LGA'
    WHEN dropoff_nyct2010_gid = 2056 THEN 'JFK'
    WHEN dropoff_nyct2010_gid = 2167 THEN 'EWR'
  END AS airport_code,
  EXTRACT(YEAR FROM pickup_datetime) AS year,
  EXTRACT(DOW FROM pickup_datetime) AS dow,
  EXTRACT(HOUR FROM pickup_datetime) AS hour,
  CASE
    WHEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60 BETWEEN 0.1 AND 240
    THEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60
  END AS duration_in_minutes
FROM trips
WHERE dropoff_nyct2010_gid IN (1840, 2056, 2167);

CREATE INDEX index_airport_trips ON airport_trips (pickup_nyct2010_gid);
CREATE INDEX index_airport_trips_dow ON airport_trips (dow);
      
-- STEP 2. Find only Friday trips from airport_trips, then for each of the airport, find the count of trips, mean of trip duration, and median of trip duration.

CREATE TABLE midtown_to_airports_friday_summary_daily AS
select airport_code,
       COUNT(*) AS trips_count,
       AVG(duration_in_minutes) AS mean,
       median(duration_in_minutes::NUMERIC) as median
from airport_trips at
      join nyct2010 ct on at.pickup_nyct2010_gid = ct.gid
                          and (ct.ntaname = 'Midtown-Midtown South' or ct.ntaname = 'Turtle Bay-East Midtown')
where at.dow = 5
group by airport_code
order by airport_code;

-- STEP 3. Find only Friday trips from airport_trips, then for each of the airport, group the trips by the hour, and then get count of trips, mean of trip duration and median of trip duration

CREATE TABLE midtown_to_airports_friday_summary_hourly AS
select airport_code,
       hour,
       COUNT(*) AS trips_count,
       AVG(duration_in_minutes) AS mean,
       median(duration_in_minutes::NUMERIC) as median
from airport_trips at
      join nyct2010 ct on at.pickup_nyct2010_gid = ct.gid
                          and (ct.ntaname = 'Midtown-Midtown South' or ct.ntaname = 'Turtle Bay-East Midtown')
where at.dow = 5
group by airport_code, hour
order by airport_code, hour;

```




``` {r, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
```


### 2. BEST TIMESLOT FOR ADS

**Question**

You have a mobile gaming startup and based on your research, your prime target audience are people who commute in cabs. You will like to place talk radio ads on radio stations that cab drivers are likely to tune in to in manhattan, what are best timeslots for you to place these ads?

**Answer**

The ideal timeslot is the time when there are a lot of people in taxis. For this question, we shall use the pickup time as a proxy of the number of people that are in Manhattan within a timeslot. Thus the dataset for this analysis shall be the all trips originating from all the boroughs in Manhattan, grouped by their time. We can include Uber rides for this dataset as we're only looking at the pickup location.

```

-- Step 1. Find all the trips originating in Manhattan

CREATE TABLE trips_from_manhattan_with_geohash_test AS
WITH manhattan_gids as (
  select distinct gid
  from nyct2010
  where boroname = 'Manhattan'
)
SELECT
  id,
  cab_type_id,
  pickup_datetime,
  dropoff_datetime,
  pickup_longitude,
  pickup_latitude,
  dropoff_longitude,
  dropoff_latitude,
  total_amount,
  payment_type,
  pickup_nyct2010_gid,
  dropoff_nyct2010_gid,
  EXTRACT(YEAR FROM pickup_datetime) AS year,
  EXTRACT(DOW FROM pickup_datetime) AS dow,
  EXTRACT(HOUR FROM pickup_datetime) AS hour,
  CASE
    WHEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60 BETWEEN 0.1 AND 240
    THEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60
  END AS duration_in_minutes,
  substring(ST_GeoHash(ST_SetSRID(ST_MakePoint(pickup_longitude,pickup_latitude),4326)),1,6) AS pickup_geohash
FROM trips
WHERE pickup_nyct2010_gid IN (select gid from manhattan_gids);

CREATE INDEX index_trips_from_manhattan_with_geohash_hour ON trips_from_manhattan_with_geohash_test(hour);
CREATE INDEX index_trips_from_manhattan_with_geohash_geohash ON trips_from_manhattan_with_geohash_test(pickup_geohash text_pattern_ops);

-- STEP 2. Group by the trips from Manhattan by the pickup hour, and get the count

CREATE TABLE manhattan_pickup_summary_hourly_test AS
SELECT hour, COUNT(*) as pickup_count
FROM trips_from_manhattan_with_geohash_test
GROUP BY hour;

```

### 3. TOP 5 CITY BLOCKS IN MANHATTAN

**Question**

For the same game as in question two, you would like to place ads strategically across the manhattan city blocks with the highest amount of cab traffic throughout the day. Find the top 5 city blocks (assume a geohash level 6 grid of 0.6km x 1.2km per city block) that you should be placing your ads in.

**Answer**

The analysis for this question is similar to question 2, but instead of grouping by the pickup/dropoff time, we shall group the taxi rides by the first six letters of geohash codes, and then pick the top 5 number of taxi rides from the result.

```

-- STEP 1. Group by the trips from Manhattan by pickup_geohash, and get the count.

CREATE TABLE manhattan_pickup_summary_geohash_test AS
SELECT pickup_geohash, 
        COUNT(*) as pickup_count
FROM trips_from_manhattan_with_geohash_test
GROUP BY pickup_geohash;


```


### 4. WEATHER FORECASTS

**Question**

The weather forecast says it is going to rain on most of the days in the next couple of months (June or July). You want to adjust your timings to the following commute plans based on the past trends on how the rain has an impact on average travel times for 

1. Cab to work (Downtown area) to report to work at 10 AM in the morning on Weekdays

2. Cab in the evenings to reach home (Midtown) between 7 PM 8 PM 

3. Saturday night trip to movies or shopping centers (in Downtown area); Pick a time when the movie starts.

4. Sunday visit to the parents home (situated in one of the suburbs) for lunch (@ 12PM)

5. A postlunch visit to your friends living a few miles away from your parents.

Based on your analysis, how much sooner or later would you start your commute for each of the above when it is raining?

**Answer**

For this question we shall define a rainy day as a day with precipitation between 0.0039 inches and 0.35 inches. We shall then separate the data between rainy day and non-rainy day for each of the cases in this question and determine how much is the difference and if they are statistically significant. The view `central_park_weather_observation` precipitation column is already converting the unit from raw data to inches.

*Case 1* For this case, we shall compare the duration of taxi rides to Downtown from home (Midtown) between rainy days and non-rainy days. We are only interested for trips that reaches Downtown before 10AM (extract hour as 9). Downtown is also known as Lower Manhattan, and thus we're interested in trips originating from 'Lower East Side' and 'Battery Park City-Lower Manhattan'.

```
STEP 1. All trips from Midtown to Downtown

CREATE TABLE trips_from_midtown_to_downtown_test AS
WITH midtown_gids as (
  select distinct gid
  from nyct2010
  where ntaname = 'Midtown-Midtown South' or ntaname = 'Turtle Bay-East Midtown'
), downtown_gids as (
  select distinct gid
  from nyct2010
  where ntaname = 'Battery Park City-Lower Manhattan' or ntaname = 'Lower East Side'
)
SELECT
  id,
  cab_type_id,
  pickup_datetime,
  dropoff_datetime,
  pickup_longitude,
  pickup_latitude,
  dropoff_longitude,
  dropoff_latitude,
  total_amount,
  payment_type,
  pickup_nyct2010_gid,
  dropoff_nyct2010_gid,
  EXTRACT(YEAR FROM pickup_datetime) AS year,
  EXTRACT(DOW FROM pickup_datetime) AS dow,
  EXTRACT(HOUR FROM pickup_datetime) AS hour,
  CASE
    WHEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60 BETWEEN 0.1 AND 240
    THEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60
  END AS duration_in_minutes
FROM trips
WHERE trips.pickup_nyct2010_gid IN (select gid from midtown_gids)
      AND trips.dropoff_nyct2010_gid IN (select gid from downtown_gids);

CREATE INDEX index_trips_from_midtown_to_downtown_test_dow ON trips_from_midtown_to_downtown_test(dow);
CREATE INDEX index_trips_from_midtown_to_downtown_test_hour ON trips_from_midtown_to_downtown_test(hour);

STEP 2. Filter it further to just Weekdays with dropoff hour extract = 9, and get the date to be joined later

CREATE TABLE trips_from_midtown_to_downtown_test_weekdays_9 AS
SELECT
  id,
  cab_type_id,
  pickup_datetime,
  dropoff_datetime,
  pickup_longitude,
  pickup_latitude,
  dropoff_longitude,
  dropoff_latitude,
  total_amount,
  payment_type,
  pickup_nyct2010_gid,
  dropoff_nyct2010_gid,
  year,
  dow,
  hour,
  date(dropoff_datetime) AS dropoff_date,
  CASE
    WHEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60 BETWEEN 0.1 AND 240
    THEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60
  END AS duration_in_minutes
FROM trips_from_midtown_to_downtown_test
WHERE EXTRACT(HOUR FROM dropoff_datetime) = 9 AND dow IN (1,2,3,4,5);

CREATE INDEX index_trips_from_midtown_to_downtown_test_weekdays_9_dropoff_date ON trips_from_midtown_to_downtown_test_weekdays_9(dropoff_date);

STEP 3. JOIN with central_park_weather_observation to find rainy/sunny days. 0 = rain, 1 = sunny

CREATE TABLE trips_from_midtown_to_downtown_test_weekdays_9_weather AS
SELECT
    t.dropoff_date,
    t.duration_in_minutes,
    CASE
        WHEN w.precipitation >= 0.0039 AND w.precipitation <= 0.35 THEN 0
        ELSE 1
    END AS weather_indicator
FROM trips_from_midtown_to_downtown_test_weekdays_9 t
    INNER JOIN central_park_weather_observations w ON t.dropoff_date = w.date;
    
STEP 4. Aggregate to find mean and SD of trip duration grouped by weather

SELECT 
    weather_indicator,
    COUNT(*) AS trip_count,
    AVG(duration_in_minutes) AS mean,
    stddev(duration_in_minutes) AS sd
FROM trips_from_midtown_to_downtown_test_weekdays_9_weather
GROUP BY weather_indicator;
      
      
```


*Case 2* Similar to case 1, but the destination is Midtown, origin from Downtown, and the relevant timeslot is weekdays 7PM to 8PM instead.

```

STEP 1. Similar to Case 1, but from Downtown to Midtown instead.

CREATE TABLE trips_from_downtown_to_midtown_test AS
WITH midtown_gids as (
  select distinct gid
  from nyct2010
  where ntaname = 'Midtown-Midtown South' or ntaname = 'Turtle Bay-East Midtown'
), downtown_gids as (
  select distinct gid
  from nyct2010
  where ntaname = 'Battery Park City-Lower Manhattan' or ntaname = 'Lower East Side'
)
SELECT
  id,
  cab_type_id,
  pickup_datetime,
  dropoff_datetime,
  pickup_longitude,
  pickup_latitude,
  dropoff_longitude,
  dropoff_latitude,
  total_amount,
  payment_type,
  pickup_nyct2010_gid,
  dropoff_nyct2010_gid,
  EXTRACT(YEAR FROM pickup_datetime) AS year,
  EXTRACT(DOW FROM pickup_datetime) AS dow,
  EXTRACT(HOUR FROM pickup_datetime) AS hour,
  CASE
    WHEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60 BETWEEN 0.1 AND 240
    THEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60
  END AS duration_in_minutes
FROM trips
WHERE trips.pickup_nyct2010_gid IN (select gid from downtown_gids)
      AND trips.dropoff_nyct2010_gid IN (select gid from midtown_gids);
      
      
CREATE INDEX index_trips_from_downtown_to_midtown_test_dow ON trips_from_downtown_to_midtown_test(dow);
CREATE INDEX index_trips_from_downtown_to_midtown_test_hour ON trips_from_downtown_to_midtown_test(hour);

STEP 2. Filter it further to just Weekdays with dropoff hour extract = 9, and get the date to be joined later

CREATE TABLE trips_from_downtown_to_midtown_test_weekdays_19 AS
SELECT
  id,
  cab_type_id,
  pickup_datetime,
  dropoff_datetime,
  pickup_longitude,
  pickup_latitude,
  dropoff_longitude,
  dropoff_latitude,
  total_amount,
  payment_type,
  pickup_nyct2010_gid,
  dropoff_nyct2010_gid,
  year,
  dow,
  hour,
  date(dropoff_datetime) AS dropoff_date,
  CASE
    WHEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60 BETWEEN 0.1 AND 240
    THEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60
  END AS duration_in_minutes
FROM trips_from_midtown_to_downtown_test
WHERE EXTRACT(HOUR FROM dropoff_datetime) = 19 AND dow IN (1,2,3,4,5);

CREATE INDEX index_trips_from_downtown_to_midtown_test_weekdays_19_dropoff_date ON trips_from_downtown_to_midtown_test_weekdays_19(dropoff_date);


STEP 3. JOIN with central_park_weather_observation to find rainy/sunny days. 0 = rain, 1 = sunny

CREATE TABLE trips_from_downtown_to_midtown_test_weekdays_19_weather AS
SELECT
    t.dropoff_date,
    t.duration_in_minutes,
    CASE
        WHEN w.precipitation >= 0.0039 AND w.precipitation <= 0.35 THEN 0
        ELSE 1
    END AS weather_indicator
FROM trips_from_downtown_to_midtown_test_weekdays_19 t
    INNER JOIN central_park_weather_observations w ON t.dropoff_date = w.date;
    
STEP 4. Aggregate to find mean and SD of trip duration grouped by weather

SELECT 
    weather_indicator,
    COUNT(*) AS trip_count,
    AVG(duration_in_minutes) AS mean,
    stddev(duration_in_minutes) AS sd
FROM trips_from_downtown_to_midtown_test_weekdays_19_weather
GROUP BY weather_indicator;


```

*Case 3* The movie starts at 7PM (need to arrive before 7PM, so extract hour = 18) and we are leaving from home, so for this case we shall compare those with origin Midtown, destination Downtown. Similar to case 1, but this time we are looking at Satudays of week days.

```

STEP 1. Using Step 1's trips_from_midtown_to_downtown_test table, get only those in the required timeslot.

CREATE TABLE trips_from_midtown_to_downtown_test_saturday_18 AS
SELECT
  id,
  cab_type_id,
  pickup_datetime,
  dropoff_datetime,
  pickup_longitude,
  pickup_latitude,
  dropoff_longitude,
  dropoff_latitude,
  total_amount,
  payment_type,
  pickup_nyct2010_gid,
  dropoff_nyct2010_gid,
  year,
  dow,
  hour,
  date(dropoff_datetime) AS dropoff_date,
  CASE
    WHEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60 BETWEEN 0.1 AND 240
    THEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60
  END AS duration_in_minutes
FROM trips_from_midtown_to_downtown_test
WHERE EXTRACT(HOUR FROM dropoff_datetime) = 18 AND dow = 6;

CREATE INDEX index_trips_from_midtown_to_downtown_test_saturday_18_dropoff_date ON trips_from_midtown_to_downtown_test_saturday_18(dropoff_date);

STEP 3. JOIN with central_park_weather_observation to find rainy/sunny days. 0 = rain, 1 = sunny

CREATE TABLE trips_from_midtown_to_downtown_test_saturday_18_weather AS
SELECT
    t.dropoff_date,
    t.duration_in_minutes,
    CASE
        WHEN w.precipitation >= 0.0039 AND w.precipitation <= 0.35 THEN 0
        ELSE 1
    END AS weather_indicator
FROM trips_from_midtown_to_downtown_test_saturday_18 t
    INNER JOIN central_park_weather_observations w ON t.dropoff_date = w.date;
    
STEP 4. Aggregate to find mean and SD of trip duration grouped by weather

SELECT 
    weather_indicator,
    COUNT(*) AS trip_count,
    AVG(duration_in_minutes) AS mean,
    stddev(duration_in_minutes) AS sd
FROM trips_from_midtown_to_downtown_test_saturday_18_weather
GROUP BY weather_indicator;
      
```


*Case 4* We shall pick a suburb Bay Ridge, Brooklyn as the destination this time, and the relevant timeslot is 11AM - 12PM on Sunday.


```

STEP 1. Find all trips from Midtown (home) to Bay Ridge (Parent's home).

CREATE TABLE trips_from_midtown_to_bayridge_test AS
WITH midtown_gids as (
  select distinct gid
  from nyct2010
  where ntaname = 'Midtown-Midtown South' or ntaname = 'Turtle Bay-East Midtown'
), bayridge_gids as (
  select distinct gid
  from nyct2010
  where ntaname = 'Bay Ridge'
)
SELECT
  id,
  cab_type_id,
  pickup_datetime,
  dropoff_datetime,
  pickup_longitude,
  pickup_latitude,
  dropoff_longitude,
  dropoff_latitude,
  total_amount,
  payment_type,
  pickup_nyct2010_gid,
  dropoff_nyct2010_gid,
  EXTRACT(YEAR FROM pickup_datetime) AS year,
  EXTRACT(DOW FROM pickup_datetime) AS dow,
  EXTRACT(HOUR FROM pickup_datetime) AS hour,
  CASE
    WHEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60 BETWEEN 0.1 AND 240
    THEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60
  END AS duration_in_minutes
FROM trips
WHERE trips.pickup_nyct2010_gid IN (select gid from midtown_gids)
      AND trips.dropoff_nyct2010_gid IN (select gid from bayridge_gids);

CREATE INDEX index_trips_from_midtown_to_bayridge_dow ON trips_from_midtown_to_bayridge_test(dow);
CREATE INDEX index_trips_from_midtown_to_bayridge_hour ON trips_from_midtown_to_bayridge_test(hour);

STEP 2. Filter it further to just Sunday with dropoff hour 11, and get the date to be joined later

CREATE TABLE trips_from_midtown_to_bayridge_sunday_11 AS
SELECT
  id,
  cab_type_id,
  pickup_datetime,
  dropoff_datetime,
  pickup_longitude,
  pickup_latitude,
  dropoff_longitude,
  dropoff_latitude,
  total_amount,
  payment_type,
  pickup_nyct2010_gid,
  dropoff_nyct2010_gid,
  year,
  dow,
  hour,
  date(dropoff_datetime) AS dropoff_date,
  CASE
    WHEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60 BETWEEN 0.1 AND 240
    THEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60
  END AS duration_in_minutes
FROM trips_from_midtown_to_downtown_test
WHERE EXTRACT(HOUR FROM dropoff_datetime) = 11 AND dow IN (0);

CREATE INDEX index_trips_from_midtown_to_bayridge_sunday_11_dropoff_date ON trips_from_midtown_to_bayridge_sunday_11(dropoff_date);

STEP 3. JOIN with central_park_weather_observation to find rainy/sunny days. 0 = rain, 1 = sunny

CREATE TABLE trips_from_midtown_to_bayridge_sunday_11_weather AS
SELECT
    t.dropoff_date,
    t.duration_in_minutes,
    CASE
        WHEN w.precipitation >= 0.0039 AND w.precipitation <= 0.35 THEN 0
        ELSE 1
    END AS weather_indicator
FROM trips_from_midtown_to_bayridge_sunday_11 t
    INNER JOIN central_park_weather_observations w ON t.dropoff_date = w.date;
    
STEP 4. Aggregate to find mean and SD of trip duration grouped by weather

SELECT 
    weather_indicator,
    COUNT(*) AS trip_count,
    AVG(duration_in_minutes) AS mean,
    stddev(duration_in_minutes) AS sd
FROM trips_from_midtown_to_bayridge_sunday_11_weather
GROUP BY weather_indicator;

```


*Case 5* We shall pick the friend's place as Crown's Heights North suburb, again in Broklyn. We shall arrive at friend's place at or before 3PM on Sunday.

```

STEP 1. Find all trips from Bay Ridge to Crown's Heights

CREATE TABLE trips_from_bayridge_to_crownheights_test AS
WITH crownheights_gids as (
  select distinct gid
  from nyct2010
  where ntaname = 'Crown Heights North'
), bayridge_gids as (
  select distinct gid
  from nyct2010
  where ntaname = 'Bay Ridge'
)
SELECT
  id,
  cab_type_id,
  pickup_datetime,
  dropoff_datetime,
  pickup_longitude,
  pickup_latitude,
  dropoff_longitude,
  dropoff_latitude,
  total_amount,
  payment_type,
  pickup_nyct2010_gid,
  dropoff_nyct2010_gid,
  EXTRACT(YEAR FROM pickup_datetime) AS year,
  EXTRACT(DOW FROM pickup_datetime) AS dow,
  EXTRACT(HOUR FROM pickup_datetime) AS hour,
  CASE
    WHEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60 BETWEEN 0.1 AND 240
    THEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60
  END AS duration_in_minutes
FROM trips
WHERE trips.pickup_nyct2010_gid IN (select gid from bayridge_gids)
      AND trips.dropoff_nyct2010_gid IN (select gid from crownheights_gids);
      
CREATE INDEX index_trips_from_bayridge_to_crownheights_test_dow ON trips_from_bayridge_to_crownheights_test(dow);
CREATE INDEX index_trips_from_bayridge_to_crownheights_test_hour ON trips_from_bayridge_to_crownheights_test(hour);
      
STEP 2. Filter it further to just Sunday with dropoff hour 15, and get the date to be joined later

CREATE TABLE trips_from_bayridge_to_crownheights_sunday_14 AS
SELECT
  id,
  cab_type_id,
  pickup_datetime,
  dropoff_datetime,
  pickup_longitude,
  pickup_latitude,
  dropoff_longitude,
  dropoff_latitude,
  total_amount,
  payment_type,
  pickup_nyct2010_gid,
  dropoff_nyct2010_gid,
  year,
  dow,
  hour,
  date(dropoff_datetime) AS dropoff_date,
  CASE
    WHEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60 BETWEEN 0.1 AND 240
    THEN EXTRACT(EPOCH FROM dropoff_datetime - pickup_datetime) / 60
  END AS duration_in_minutes
FROM trips_from_midtown_to_downtown_test
WHERE EXTRACT(HOUR FROM dropoff_datetime) = 14 AND dow IN (0);

CREATE INDEX index_trips_from_bayridge_to_crownheights_sunday_14_dropoff_date ON trips_from_bayridge_to_crownheights_sunday_14(dropoff_date);

STEP 3. JOIN with central_park_weather_observation to find rainy/sunny days. 0 = rain, 1 = sunny

CREATE TABLE trips_from_bayridge_to_crownheights_sunday_14_weather AS
SELECT
    t.dropoff_date,
    t.duration_in_minutes,
    CASE
        WHEN w.precipitation >= 0.0039 AND w.precipitation <= 0.35 THEN 0
        ELSE 1
    END AS weather_indicator
FROM trips_from_bayridge_to_crownheights_sunday_14 t
    INNER JOIN central_park_weather_observations w ON t.dropoff_date = w.date;
    
STEP 4. Aggregate to find mean and SD of trip duration grouped by weather

SELECT 
    weather_indicator,
    COUNT(*) AS trip_count,
    AVG(duration_in_minutes) AS mean,
    stddev(duration_in_minutes) AS sd
FROM trips_from_bayridge_to_crownheights_sunday_14_weather
GROUP BY weather_indicator;

```


